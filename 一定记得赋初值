啊啊啊c语言老是不小心错这错那的
总结一下吧


6-3 使用函数求奇数和 （15 分）本题要求实现一个函数，计算N个整数中所有奇数的和，同时实现一个判断奇偶性的函数。
函数接口定义：
int even( int n );
int OddSum( int List[], int N );
其中函数even将根据用户传入的参数n的奇偶性返回相应值：当n为偶数时返回1，否则返回0。函数OddSum负责计算并返回传入的N个整数List[]中所有奇数的和。
我第一次写的代码里面将没有定义的字符用进去了。。。编译错误。。。所以即使他很简单我也。。。
贴一下正确的代码
int even(int n)
{
if (n % 2 == 0)
return 1;
else
return 0;
}
int OddSum(int List[], int N)
{
int j,sum = 0;
for (j = 0;j<N;j++)
{
if (List[j] % 2 != 0)
sum += List[j];
}
return(sum);
}
然后是一个求最大公约数的，开始我没有认真看题目，以为是求公约数和公倍数。。。。泪水啊。。我简直是浪费时间的好手。




不过还是复习一下最大公约数公倍数的算法吧

是之前的作业
我还是再写一遍吧
#include<stdio.h>
int main(void)
{
int m, n, pro;//一开始就要定义一下m n之积，因为后面两者会变//
scanf("%d %d", &m, &n);
pro = m * n;
int r, t;//注意r无初值//
if (m < n) {
t = m;
m = n;
n = t;
}
do {//在这里不能用while(r != 0) 因为r没有初始化，没有值，所以编译错误，应该用do while//
r = m % n;
m = n;
n = r;
} while ®;//在这里要用引号//
printf("%d %d", m, pro / m);
return 0;
}
在这个代码里面我又出现了没有初始化的值直接拿来用的错误。。。等一下，这周的作业我刚刚出现这个错误，我是不长记性吧。。来分享一下这周的错，我觉得现在错了两次应该以后都不要错了吧吧吧
啊忘记在哪一题了
但是以后一定要记得啊啊啊啊
还是说一下我经常没有初始化的情况吧


主要是 一些类似flag的变量，还有sum,count;还有最重要的 数组啊啊啊特别是字符数组 烫烫烫 太可怕了第一次遇到的时候。




还做了一个挺简单的题这周的题比较简单吧
6-8 字符串复制 （10 分）将一个字符串复制到另外一个字符串中。
函数接口定义：
void fun(char a[],char b[]);
参数a和b是用户传入的参数。 函数将字符串a复制到字符串b中
void fun(char a[],char b[])
{
int i,count=0;//count要赋初值//
for(i=0;i<80;i++)
b[i]=0;
for(i=0;a[i]!=’\0’;i++){ //因为没有用string.h不知道字符数组的长度//
count++;
}
for(i=0;i<count;i++){
b[i]=a[i];
}
}
这周虽然题目比较简单，但是我的c语言期中考不好，所以。。唉
把前几周的总结一下吧。
下一篇见。

补充







6-7 求一组数中的最大值、最小值和平均值 （10 分）
编写函数，求一组数中的最大值、最小值和平均值。
函数接口定义：
float fun(int a[],int n,int *max,int *min);
其中 a、n、max 和 min 都是用户传入的参数。函数求a数组中n个元素的最大值、最小值和平均值。最大值和最小值分别通过max 和 min带回，函数返回平均值 。



#include <stdio.h>
float fun(int a[], int n, int *max, int *min);
int main()
{
	int x[10], i, m, n;
	float p;
	for (i = 0;i<10;i++)
		scanf("%d", &x[i]);
	p = fun(x, 10, &m, &n);
	printf("max=%d,min=%d,average=%.2f\n", m, n, p);
	return 0;
}

float fun(int a[], int n, int *max, int *min)
{
	int *p;
	float sum = 0;
	*max = *min = *a;//要赋初值。。不然 出来的min是个鬼东西
	for (p = a ; p < a + n; p++)
	{
		if (*p > *max)
			*max = *p;
		else if (*p < *min)
			*min = *p;
		sum += *p;
	}
	return sum / n;
}
