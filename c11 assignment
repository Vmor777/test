

11周作业


首先涉及到了查找的方面

题目要求的是顺序查找









7-2 查找指定字符 （15 分）本题要求编写程序，从给定字符串中查找某指定的字符。

输入格式：

输入的第一行是一个待查找的字符。第二行是一个以回车结束的非空字符串（不超过80个字符）。

输出格式：

#include<stdio.h>

#include<string.h>

 

int main(void)

{

        char c;

        int i;

        char str[100] = { 0 };//要赋予初值

        scanf("%c", &c);

        char ch;

        ch = getchar();//吸收空格,在gets之前要吸收

        gets(str);

        for (i = 0;i < strlen(str); i++) {

                 if (str[i] == c) break;

 

        }

        printf("%d", i);

        return 0；
        }













到了顺序查找，想到了只能在有序情况下的二分查找 没有找到什么题 自己写了一下
#include<stdio.h>

int main(void)

{

 int n, a[1000] = { 0 },x;

 int i, high, low = 0, mid;

 scanf("%d %d", &n,&x);

 high = n - 1;

 for (i = 0;i < n ;i++) {

  scanf("%d", &a[i]);

 }

 while (low < high) {//记得这个条件啊啊

  mid = (high + low) / 2;

  if (a[mid] < x)

   low = mid + 1;

  else if (a[mid] > x)

   high = mid - 1;

  else

   break;

 }

 printf("%d", mid);

 return 0;

}

既然 说到有序 就复习一下排序好了



 

冒泡排序

#include <stdio.h>

 

int main(void)

{

        int a[10];

        int i, j, t;

 

        printf("input 10 numbers :\n");

        for (i = 0; i < 10; ++i)

                 scanf("%d", &a[i]);

        printf("\n");

 

        for (j = 1; j < 10; j++) // 共进行9趟排序

        {

                 for (i = 0; i < 10 - j; i++)  // 第j趟需比较10-j次

                 {

                         if (a[i] > a[i + 1]) //a[i]和a[i+1]逆序则交换

                         {

                                  t = a[i]; a[i]= a[i + 1]; a[i + 1] = t;

                         }

                 }

        }

        for (i = 0;i < 10;i++)

                 printf("%d", a[i]);

        return 0;
        }

 

 

 

选择排序

 

#include<stdio.h>

 

int main(void)

{

        int i, j, k,t;

        int a[1000] = { 0 };

        int n;

        scanf("%d", &n);

        for (i = 0;i < n;i++) {

                 scanf("%d", &a[i]);

        }

        for (i = 0;i < n-1;i++) {

                 k = i;//k相当于一个最小值的下标

                 for (j = i + 1;j < n;j++) {

                         if (a[k] < a[j])

                                  k = j;//找到最小值的下标

                         t = a[k];a[k] =a[i];a[i] = t;//是i的下标

                 }

        }

        for(i = 0;i < n;i++)

                 printf("%d ", a[i]);

        return 0;
        }
        还有其他的排序
        以后慢慢写出来
